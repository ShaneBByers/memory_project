#include <stdio.h>
#include <sys/mman.h>
#include <assert.h>

typedef struct __node_t {
	int size;
	struct __node_t *next;
} node_t;

typedef struct __header_t {
	int size;
	int magic;
} header_t;

node_t *head;
int algo;
int max_size;

int psumeminit(int algo_code, int region_size) {
	head = mmap(NULL, region_size, PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, -1, 0);
	head->size = region_size - sizeof(node_t);
	head->next = NULL;
	algo = algo_code;
	max_size = head->size;
	return 0;
}

void psumemdump() {
	printf("----BEGIN OUTPUT----\n");
	printf("Head Address:%p\n",head);
	printf("$$Free Nodes$$\n");
	node_t * temp_node = head;
	int counter = 0;
	while(temp_node) {
		printf("Node %d:\n",counter);
		printf("  Location: %p\n",temp_node);
		printf("  Size: %d\n",temp_node->size);
		temp_node = temp_node->next;
		counter++;
	}
	printf("----END   OUTPUT----\n\n\n");
}

void combine_free() {
	node_t * loop_node = head;
	node_t * curr_node;
	node_t * prev_node = NULL;
	while(loop_node) {
		curr_node = head;
		while(curr_node) {
			if(curr_node == head) {
				prev_node = NULL;
			}
			if(curr_node == loop_node + loop_node->size) {
				loop_node->size = loop_node->size + curr_node->size;
				if(!prev_node && curr_node->next) {
					head = curr_node->next;
				} else if(!prev_node && !curr_node->next) {
				} else {
					prev_node->next = curr_node->next;
				}
				loop_node = head;
				curr_node = head;
			} else {
				prev_node = curr_node;
				curr_node = curr_node->next;
			}
		}
		loop_node = loop_node->next;
	}
}

node_t * best_fit_finder(int size) {
	node_t * temp_node = head;
	node_t * best_fit_node = temp_node;
	int best_size_diff = best_fit_node->size - (signed int)(size + sizeof(header_t));
	int size_diff;
	while(temp_node) {
		size_diff = temp_node->size - (signed int)(size + sizeof(header_t));
		if(size_diff >= 0 && size_diff < best_size_diff) {
			best_fit_node = temp_node;
			best_size_diff = best_fit_node->size - (signed int)(size + sizeof(header_t));
		}
		temp_node = temp_node->next;
	}
	return best_fit_node;
}

node_t * worst_fit_finder(int size) {
	node_t * temp_node = head;
	node_t * worst_fit_node = temp_node;
	int worst_size_diff = worst_fit_node->size - (signed int)(size + sizeof(header_t));
	int size_diff;
	while(temp_node) {
		size_diff = temp_node->size - (signed int)(size + sizeof(header_t));
		if(size_diff >= 0 && size_diff > worst_size_diff) {
			worst_fit_node = temp_node;
			worst_size_diff = worst_fit_node->size - (signed int)(size + sizeof(header_t));
		}
		temp_node = temp_node->next;
	}
	return worst_fit_node;
}

void *psumalloc(int size) {
	if(size > (signed int)(max_size - sizeof(header_t))) {
		return NULL;
	}
	node_t * temp_node;
	if(algo == 0) {
		temp_node = best_fit_finder(size);
	} else {
		temp_node = worst_fit_finder(size);
	}
	void * return_ptr = (void *)((int *)temp_node + sizeof(header_t));
	node_t * loop_node = head;
	node_t * prev_node = NULL;
	while(loop_node != temp_node) {
		prev_node = loop_node;
		loop_node = loop_node->next;
	}
	header_t * header;
	int temp_size = loop_node->size;
	node_t * temp_next = loop_node->next;
	header = (header_t *)loop_node;
	header->size = size;
	header->magic = 473;
	if(prev_node) {
		loop_node = loop_node + sizeof(header_t) + size;
		prev_node->next = loop_node;
		loop_node->size = temp_size - sizeof(header_t) - size;
		loop_node->next = temp_next;
	} else {
		head = head + sizeof(header_t) + size;
		head->size = temp_size - sizeof(header_t) - size;
		head->next = temp_next;
	}
	return return_ptr;
}

int psufree(void *ptr) {
	node_t * temp_head = head;
	header_t * header = (header_t *)((int *)ptr - sizeof(header_t));
	assert(header->magic==473);
	head = (node_t *)header;
	head->size = header->size + sizeof(header_t);
	head->next = temp_head;
	combine_free();
	return 1;
}

int main() {
	psumeminit(0,4096);
	psumemdump();
	printf("MALLOC 1\n");
	void * current1 = psumalloc(24);
	psumemdump();
	printf("MALLOC 2\n");
	void * current2 = psumalloc(16);
	psumemdump();
	printf("MALLOC 3\n");
	void * current3 = psumalloc(8);
	psumemdump();
	printf("FREE 2\n");
	psufree(current2);
	psumemdump();
	printf("MALLOC 4\n");
	void * current4 = psumalloc(8);
	psumemdump();
	printf("FREE 1\n");
	psufree(current1);
	psumemdump();
	printf("FREE 3\n");
	psufree(current3);
	psumemdump();
	printf("FREE 4\n");
	psufree(current4);
	psumemdump();
	return 0;
}
